name: Build Complete wc3data WebAssembly Library

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'

    - name: Setup Emscripten
      uses: mymindstorm/setup-emsdk@v14
      with:
        version: 'latest'
        actions-cache-folder: 'emsdk-cache'

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential cmake

    - name: Verify Emscripten installation
      run: |
        emcc --version
        em++ --version
        which emcc

    - name: Create build directory
      run: mkdir -p build

    - name: Analyze project structure
      run: |
        echo "=== Repository structure ==="
        find . -maxdepth 3 -type f -name "*.cpp" -not -path "./emsdk*" -not -path "./.git*" | sort
        echo ""
        echo "=== Header files ==="
        find . -maxdepth 3 -type f -name "*.h" -not -path "./emsdk*" -not -path "./.git*" | head -10
        echo ""
        echo "=== DataGen directory ==="
        ls -la DataGen/ || echo "DataGen directory not found"
        echo ""
        echo "=== Looking for webmain or similar ==="
        find . -name "*web*" -type f | head -10

    - name: Build complete wc3data library
      run: |
        echo "Building complete wc3data WebAssembly library..."
        
        # Recopilar todos los archivos fuente necesarios excluyendo los problemáticos
        CPP_FILES=$(find ./DataGen -name "*.cpp" \
          -not -path "*/ngdp/*" \
          -not -name "main.cpp" \
          -not -name "*test*" \
          -not -name "*example*" | tr '\n' ' ')
        
        echo "Found CPP files: $CPP_FILES"
        
        # Verificar que tenemos archivos para compilar
        if [ -z "$CPP_FILES" ]; then
          echo "No suitable CPP files found!"
          exit 1
        fi
        
        # Compilar la biblioteca completa
        em++ -std=c++17 -O2 \
          -s WASM=1 \
          -s MODULARIZE=1 \
          -s EXPORT_NAME='WC3Module' \
          -s EXPORTED_RUNTIME_METHODS='["FS","ccall","cwrap","getValue","setValue","UTF8ToString","stringToUTF8","lengthBytesUTF8","writeArrayToMemory"]' \
          -s EXPORTED_FUNCTIONS='["_malloc","_free","_main"]' \
          -s ALLOW_MEMORY_GROWTH=1 \
          -s MAXIMUM_MEMORY=2147483648 \
          -s FILESYSTEM=1 \
          -s FORCE_FILESYSTEM=1 \
          -s ASSERTIONS=1 \
          -s EXCEPTION_CATCHING_ALLOWED='[..]' \
          -s ERROR_ON_UNDEFINED_SYMBOLS=0 \
          -s WARN_ON_UNDEFINED_SYMBOLS=0 \
          -Wno-nontrivial-memcall \
          -Wno-unused-variable \
          -Wno-unused-function \
          --bind \
          -I. -Isrc -IDataGen \
          -DEMSCRIPTEN \
          -DUSE_EMSCRIPTEN \
          -DNO_WINDOWS \
          -DNO_CURL \
          -DNO_HTTP \
          -DWEB_BUILD \
          $CPP_FILES \
          -o build/wc3data.js \
          -s ENVIRONMENT='web,worker'

    - name: Create Web API wrapper
      run: |
        cat > build/wc3data-api.js << 'EOF'
        /**
         * wc3data WebAssembly API Wrapper
         * Provides easy-to-use JavaScript API for WC3 map manipulation
         */
        class WC3DataAPI {
          constructor(module) {
            this.module = module;
            this.FS = module.FS;
          }
          
          /**
           * Load a WC3 map from binary data
           * @param {Uint8Array} mapData - The map file data
           * @param {string} filename - Optional filename
           * @returns {Promise<WC3Map>} Map instance
           */
          async loadMap(mapData, filename = 'map.w3x') {
            // Write map data to virtual filesystem
            this.FS.writeFile('/' + filename, mapData);
            
            // Create map instance
            const map = new WC3Map(this.module, filename);
            await map.load();
            return map;
          }
          
          /**
           * Create a new empty map
           * @returns {WC3Map} New map instance
           */
          createMap() {
            return new WC3Map(this.module);
          }
        }
        
        class WC3Map {
          constructor(module, filename = null) {
            this.module = module;
            this.FS = module.FS;
            this.filename = filename;
            this.loaded = false;
          }
          
          /**
           * Load the map data
           */
          async load() {
            if (this.filename && this.FS.analyzePath('/' + this.filename).exists) {
              // Call native parsing function if available
              try {
                // Try to call webmain or parsing function
                if (this.module.ccall) {
                  this.module.ccall('webmain', 'number', ['number', 'number'], [0, 0]);
                }
                this.loaded = true;
              } catch (e) {
                console.warn('Native parsing not available, using basic file access');
                this.loaded = true;
              }
            }
          }
          
          /**
           * Get a file from the map archive
           * @param {string} path - File path (e.g., 'war3map.j')
           * @returns {string|Uint8Array} File content
           */
          getFile(path) {
            try {
              const fullPath = '/' + this.filename + '/' + path;
              if (this.FS.analyzePath(fullPath).exists) {
                return this.FS.readFile(fullPath, { encoding: 'utf8' });
              }
              
              // Try alternative path
              const altPath = '/' + path;
              if (this.FS.analyzePath(altPath).exists) {
                return this.FS.readFile(altPath, { encoding: 'utf8' });
              }
              
              return null;
            } catch (e) {
              console.error('Error reading file:', path, e);
              return null;
            }
          }
          
          /**
           * Get a file as binary data
           * @param {string} path - File path
           * @returns {Uint8Array} File content as binary
           */
          getFileBinary(path) {
            try {
              const fullPath = '/' + this.filename + '/' + path;
              if (this.FS.analyzePath(fullPath).exists) {
                return this.FS.readFile(fullPath);
              }
              
              const altPath = '/' + path;
              if (this.FS.analyzePath(altPath).exists) {
                return this.FS.readFile(altPath);
              }
              
              return null;
            } catch (e) {
              console.error('Error reading binary file:', path, e);
              return null;
            }
          }
          
          /**
           * Set/update a file in the map
           * @param {string} path - File path
           * @param {string|Uint8Array} content - File content
           */
          setFile(path, content) {
            try {
              const fullPath = '/' + path;
              if (typeof content === 'string') {
                this.FS.writeFile(fullPath, content);
              } else {
                this.FS.writeFile(fullPath, content);
              }
            } catch (e) {
              console.error('Error writing file:', path, e);
              throw e;
            }
          }
          
          /**
           * List all files in the map
           * @returns {string[]} Array of file paths
           */
          listFiles() {
            try {
              const files = [];
              const traverse = (path) => {
                const entries = this.FS.readdir(path);
                for (const entry of entries) {
                  if (entry === '.' || entry === '..') continue;
                  const fullPath = path + '/' + entry;
                  const stat = this.FS.stat(fullPath);
                  if (this.FS.isFile(stat.mode)) {
                    files.push(fullPath.replace(/^\/+/, ''));
                  } else if (this.FS.isDir(stat.mode)) {
                    traverse(fullPath);
                  }
                }
              };
              traverse('/');
              return files;
            } catch (e) {
              console.error('Error listing files:', e);
              return [];
            }
          }
          
          /**
           * Save the map as binary data
           * @returns {Uint8Array} Map binary data
           */
          save() {
            try {
              // If we have a filename, try to read the modified file
              if (this.filename && this.FS.analyzePath('/' + this.filename).exists) {
                return this.FS.readFile('/' + this.filename);
              }
              
              // Otherwise, create a simple archive (this would need native implementation)
              throw new Error('Save functionality requires native map building support');
            } catch (e) {
              console.error('Error saving map:', e);
              throw e;
            }
          }
        }
        
        // Main initialization function
        let wc3DataInstance = null;
        
        async function initWC3Data() {
          if (!wc3DataInstance) {
            console.log('Initializing WC3Data WebAssembly module...');
            const module = await WC3Module();
            wc3DataInstance = new WC3DataAPI(module);
            console.log('WC3Data module initialized successfully');
          }
          return wc3DataInstance;
        }
        
        // Export for different environments
        if (typeof module !== 'undefined' && module.exports) {
          // Node.js
          module.exports = { initWC3Data, WC3DataAPI, WC3Map };
        } else if (typeof window !== 'undefined') {
          // Browser
          window.initWC3Data = initWC3Data;
          window.WC3DataAPI = WC3DataAPI;
          window.WC3Map = WC3Map;
        }
        EOF

    - name: Create usage documentation
      run: |
        cat > build/USAGE.md << 'EOF'
        # WC3Data WebAssembly Library Usage Guide
        
        ## Files Generated
        
        - `wc3data.js` - Main WebAssembly module
        - `wc3data.wasm` - WebAssembly binary
        - `wc3data-api.js` - High-level JavaScript API wrapper
        
        ## Basic HTML Usage
        
        ```html
        <!DOCTYPE html>
        <html>
        <head>
            <title>WC3 Map Editor</title>
        </head>
        <body>
            <input type="file" id="mapFile" accept=".w3m,.w3x">
            <textarea id="scriptOutput" rows="20" cols="80"></textarea>
            
            <script src="wc3data.js"></script>
            <script src="wc3data-api.js"></script>
            <script>
                let wc3api = null;
                
                async function init() {
                    try {
                        wc3api = await initWC3Data();
                        console.log('WC3Data ready!');
                        document.getElementById('mapFile').disabled = false;
                    } catch (error) {
                        console.error('Failed to initialize WC3Data:', error);
                    }
                }
                
                document.getElementById('mapFile').addEventListener('change', async function(e) {
                    const file = e.target.files[0];
                    if (!file || !wc3api) return;
                    
                    try {
                        const arrayBuffer = await file.arrayBuffer();
                        const mapData = new Uint8Array(arrayBuffer);
                        
                        // Load the map
                        const map = await wc3api.loadMap(mapData, file.name);
                        
                        // Extract war3map.j (JASS script)
                        const jassScript = map.getFile('war3map.j');
                        if (jassScript) {
                            document.getElementById('scriptOutput').value = jassScript;
                            console.log('JASS script loaded successfully');
                        } else {
                            console.log('No JASS script found in map');
                        }
                        
                        // List all files
                        const files = map.listFiles();
                        console.log('Map contains files:', files);
                        
                    } catch (error) {
                        console.error('Error processing map:', error);
                    }
                });
                
                // Initialize when page loads
                init();
            </script>
        </body>
        </html>
        ```
        
        ## Advanced Usage
        
        ```javascript
        // Initialize the library
        const wc3api = await initWC3Data();
        
        // Load a map
        const mapData = new Uint8Array(mapFileBuffer);
        const map = await wc3api.loadMap(mapData, 'mymap.w3x');
        
        // Read files
        const jassScript = map.getFile('war3map.j');
        const mapInfo = map.getFile('war3map.w3i');
        
        // Modify files
        const modifiedScript = jassScript.replace('StartingGold', '999999');
        map.setFile('war3map.j', modifiedScript);
        
        // Save modified map (if supported)
        try {
            const modifiedMapData = map.save();
            // Download or use the modified map data
        } catch (error) {
            console.log('Save functionality may not be fully implemented yet');
        }
        ```
        
        ## File Access Patterns
        
        Common WC3 map files you can access:
        - `war3map.j` - JASS script code
        - `war3map.w3i` - Map info
        - `war3map.wts` - String data
        - `war3map.w3u` - Unit data
        - `war3map.w3t` - Item data
        - `war3map.w3a` - Ability data
        - `war3map.w3q` - Upgrade data
        
        ## Error Handling
        
        Always wrap WC3Data calls in try-catch blocks as file operations may fail:
        
        ```javascript
        try {
            const script = map.getFile('war3map.j');
            if (script) {
                // Process script
            } else {
                console.log('File not found');
            }
        } catch (error) {
            console.error('Error accessing file:', error);
        }
        ```
        EOF

    - name: Verify build output
      run: |
        echo "=== Build Results ==="
        ls -la build/
        echo ""
        echo "=== File Sizes ==="
        du -h build/*
        echo ""
        echo "=== Checking WASM file ==="
        if [ -f "build/wc3data.wasm" ]; then
          echo "✓ WASM file generated successfully"
          file build/wc3data.wasm
        else
          echo "✗ WASM file not found"
        fi
        echo ""
        echo "=== Checking JS file ==="
        if [ -f "build/wc3data.js" ]; then
          echo "✓ JS file generated successfully"
          head -10 build/wc3data.js
        else
          echo "✗ JS file not found"
        fi

    - name: Upload complete build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: wc3data-complete-library
        path: |
          build/wc3data.js
          build/wc3data.wasm
          build/wc3data-api.js
          build/USAGE.md
        retention-days: 30

    - name: Upload build logs on failure
      if: failure()
      uses: actions/upload-artifact@v4
      with:
        name: build-failure-logs
        path: |
          build/
        retention-days: 7
