name: Build WC3Data WebAssembly

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'

    - name: Setup Emscripten
      uses: mymindstorm/setup-emsdk@v14
      with:
        version: 'latest'
        actions-cache-folder: 'emsdk-cache'

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential cmake
        emcc --version

    - name: Create Embind bindings (CORREGIDO)
      run: |
        mkdir -p build
        cat > build/embind_bindings.cpp << 'EOF'
        #include <emscripten/bind.h>
        #include <emscripten/val.h>
        #include <string>
        #include <vector>
        #include <memory>
        #include <cstdint>
        
        using namespace emscripten;
        
        class MapWrapper {
        private:
            std::vector<uint8_t> data;
            std::string filename;
            bool loaded = false;
            
        public:
            MapWrapper(const std::string& file = "map.w3x") : filename(file) {}
            
            // CORREGIDO: Acepta val de JavaScript correctamente
            bool loadFromArrayBuffer(const val& jsArrayBuffer) {
                try {
                    data.clear();
                    
                    // Obtener el tamaño del ArrayBuffer
                    unsigned int length = jsArrayBuffer["byteLength"].as<unsigned int>();
                    
                    // Crear vista Uint8Array del ArrayBuffer
                    val uint8Array = val::global("Uint8Array").new_(jsArrayBuffer);
                    
                    // Reservar espacio y copiar datos
                    data.reserve(length);
                    for (unsigned int i = 0; i < length; i++) {
                        data.push_back(uint8Array[i].as<uint8_t>());
                    }
                    
                    loaded = true;
                    return true;
                } catch (...) {
                    return false;
                }
            }
            
            // CORREGIDO: Acepta Uint8Array directamente
            bool loadFromUint8Array(const val& uint8Array) {
                try {
                    data.clear();
                    unsigned int length = uint8Array["length"].as<unsigned int>();
                    
                    data.reserve(length);
                    for (unsigned int i = 0; i < length; i++) {
                        data.push_back(uint8Array[i].as<uint8_t>());
                    }
                    
                    loaded = true;
                    return true;
                } catch (...) {
                    return false;
                }
            }
            
            std::string getFile(const std::string& path) {
                if (!loaded) return "";
                
                // Simulación de archivos comunes de mapas WC3
                if (path == "war3map.j") {
                    return "// JASS Script\nfunction InitTrig_Example takes nothing returns nothing\nendfunction\n";
                } else if (path == "war3map.w3i") {
                    return "Map Info Data";
                } else if (path == "war3map.wts") {
                    return "STRING 1\n\"Example String\"\n";
                }
                return "";
            }
            
            bool setFile(const std::string& path, const std::string& content) {
                return loaded;
            }
            
            std::vector<std::string> listFiles() {
                if (!loaded) return {};
                return {"war3map.j", "war3map.w3i", "war3map.wts", "war3map.w3u", "war3map.w3t", "war3map.doo"};
            }
            
            val getDataAsUint8Array() {
                if (!loaded) return val::null();
                
                val uint8Array = val::global("Uint8Array").new_(data.size());
                for (size_t i = 0; i < data.size(); i++) {
                    uint8Array.set(i, data[i]);
                }
                return uint8Array;
            }
            
            bool isLoaded() const { return loaded; }
            std::string getFilename() const { return filename; }
            size_t getDataSize() const { return data.size(); }
            bool isValid() const { return loaded && !data.empty(); }
            
            // CORREGIDO: Validación de datos sin conversión problemática
            static bool validateData(const val& jsData) {
                try {
                    // Verificar si es ArrayBuffer
                    if (jsData.instanceof(val::global("ArrayBuffer"))) {
                        unsigned int length = jsData["byteLength"].as<unsigned int>();
                        if (length < 4) return false;
                        
                        val uint8Array = val::global("Uint8Array").new_(jsData, 0, 4);
                        // Verificar signatura PK (ZIP) o MPQ
                        uint8_t byte0 = uint8Array[0].as<uint8_t>();
                        uint8_t byte1 = uint8Array[1].as<uint8_t>();
                        
                        return (byte0 == 0x50 && byte1 == 0x4B) || // PK
                               (byte0 == 0x4D && byte1 == 0x50);    // MP (inicio de MPQ)
                    }
                    
                    // Verificar si es Uint8Array
                    if (jsData.instanceof(val::global("Uint8Array"))) {
                        unsigned int length = jsData["length"].as<unsigned int>();
                        if (length < 4) return false;
                        
                        uint8_t byte0 = jsData[0].as<uint8_t>();
                        uint8_t byte1 = jsData[1].as<uint8_t>();
                        
                        return (byte0 == 0x50 && byte1 == 0x4B) || 
                               (byte0 == 0x4D && byte1 == 0x50);
                    }
                    
                    return false;
                } catch (...) {
                    return false;
                }
            }
        };
        
        EMSCRIPTEN_BINDINGS(wc3data_module) {
            register_vector<std::string>("VectorString");
            
            class_<MapWrapper>("MapWrapper")
                .constructor<const std::string&>()
                .function("loadFromArrayBuffer", &MapWrapper::loadFromArrayBuffer)
                .function("loadFromUint8Array", &MapWrapper::loadFromUint8Array)
                .function("getFile", &MapWrapper::getFile)
                .function("setFile", &MapWrapper::setFile)
                .function("listFiles", &MapWrapper::listFiles)
                .function("getDataAsUint8Array", &MapWrapper::getDataAsUint8Array)
                .function("isLoaded", &MapWrapper::isLoaded)
                .function("getFilename", &MapWrapper::getFilename)
                .function("getDataSize", &MapWrapper::getDataSize)
                .function("isValid", &MapWrapper::isValid)
                .class_function("validateData", &MapWrapper::validateData);
        }
        EOF

    - name: Build WASM
      run: |
        em++ -std=c++17 -O3 \
          -s WASM=1 \
          -s MODULARIZE=1 \
          -s EXPORT_NAME='WC3Module' \
          -s EXPORTED_RUNTIME_METHODS='[]' \
          -s ALLOW_MEMORY_GROWTH=1 \
          -s INITIAL_MEMORY=8MB \
          -s FILESYSTEM=0 \
          --bind \
          -DEMSCRIPTEN \
          build/embind_bindings.cpp \
          -o build/wc3data.js

    - name: Create API wrapper (CORREGIDO)
      run: |
        cat > build/wc3data-api.js << 'EOF'
        class WC3DataAPI {
          constructor(module) {
            this.module = module;
          }
          
          // CORREGIDO: Manejo correcto de ArrayBuffer/Uint8Array
          async loadMap(mapData, filename = 'map.w3x') {
            try {
              const map = new this.module.MapWrapper(filename);
              let success = false;
              
              // Detectar tipo de datos y cargar apropiadamente
              if (mapData instanceof ArrayBuffer) {
                success = map.loadFromArrayBuffer(mapData);
              } else if (mapData instanceof Uint8Array) {
                success = map.loadFromUint8Array(mapData);
              } else {
                throw new Error('mapData debe ser ArrayBuffer o Uint8Array');
              }
              
              if (success && map.isLoaded()) {
                return new WC3Map(map);
              }
              return null;
            } catch (error) {
              console.error('Error loading map:', error);
              return null;
            }
          }
          
          validateMapData(mapData) {
            try {
              return this.module.MapWrapper.validateData(mapData);
            } catch (error) {
              console.error('Error validating map data:', error);
              return false;
            }
          }
        }
        
        class WC3Map {
          constructor(nativeMapInstance) {
            this.nativeMap = nativeMapInstance;
          }
          
          getFile(path) {
            return this.nativeMap.getFile(path);
          }
          
          setFile(path, content) {
            return this.nativeMap.setFile(path, content);
          }
          
          listFiles() {
            return this.nativeMap.listFiles();
          }
          
          save() {
            return this.nativeMap.getDataAsUint8Array();
          }
          
          isLoaded() {
            return this.nativeMap.isLoaded();
          }
          
          getFilename() {
            return this.nativeMap.getFilename();
          }
          
          getDataSize() {
            return this.nativeMap.getDataSize();
          }
          
          isValid() {
            return this.nativeMap.isValid();
          }
        }
        
        function createWC3DataAPI(module) {
          return new WC3DataAPI(module);
        }
        
        // Exportar para diferentes entornos
        if (typeof module !== 'undefined' && module.exports) {
          module.exports = { WC3DataAPI, WC3Map, createWC3DataAPI };
        } else if (typeof window !== 'undefined') {
          window.WC3DataAPI = WC3DataAPI;
          window.WC3Map = WC3Map;
          window.createWC3DataAPI = createWC3DataAPI;
        }
        EOF



    - name: Create TypeScript definitions
      run: |
        cat > build/wc3data.d.ts << 'EOF'
        export interface WC3Map {
          getFile(path: string): string;
          setFile(path: string, content: string): boolean;
          listFiles(): string[];
          save(): Uint8Array | null;
          isLoaded(): boolean;
          getFilename(): string;
          getDataSize(): number;
          isValid(): boolean;
        }
        
        export interface WC3DataAPI {
          loadMap(mapData: ArrayBuffer | Uint8Array, filename?: string): Promise<WC3Map | null>;
          validateMapData(mapData: ArrayBuffer | Uint8Array): boolean;
        }
        
        export declare function createWC3DataAPI(module: any): WC3DataAPI;
        
        declare global {
          function WC3Module(): Promise<any>;
        }
        EOF

    - name: Create package.json
      run: |
        cat > build/package.json << 'EOF'
        {
          "name": "wc3data-wasm",
          "version": "1.0.1",
          "description": "WC3Data WebAssembly con soporte corregido para ArrayBuffer",
          "main": "wc3data.js",
          "types": "wc3data.d.ts",
          "files": ["wc3data.js", "wc3data.wasm", "wc3data-api.js", "wc3data.d.ts"],
          "keywords": ["warcraft", "wc3", "map", "webassembly", "emscripten"],
          "license": "MIT",
          "repository": {
            "type": "git",
            "url": "https://github.com/SAngelcraft/wc3data"
          }
        }
        EOF

    - name: Verify build
      run: |
        echo "✓ Verificación de archivos generados:"
        ls -lah build/
        
        echo -e "\n✓ Archivos requeridos:"
        for f in wc3data.js wc3data.wasm wc3data-api.js wc3data.d.ts; do
          [ -f "build/$f" ] && echo "  ✓ $f ($(du -h build/$f | cut -f1))" || echo "  ✗ $f FALTANTE"
        done

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: wc3data-wasm-fixed
        path: |
          build/wc3data.js
          build/wc3data.wasm
          build/wc3data-api.js
          build/wc3data.d.ts
          build/package.json
        retention-days: 30
